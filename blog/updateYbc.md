---
slug: updateYbc
title: ✨ Yuml 架构升级：我们如何用 SQLite 实现 YAML 的惰性加载与编译执行
date: 2025-07-01
authors: [yuan]
tags: [Yuml]
---

Yuml 新版本引入了一项关键性的底层升级 ——  
我们重新设计了解析执行的整个流程，**告别重复渲染 + 全量加载的时代**，正式迈入 **字节码 + 惰性加载的高性能阶段**。

<!--truncate-->

## 🧠 问题回顾：旧架构的瓶颈

旧版本中，Yuml 的启动流程如下：

1. 读取原始 `.yaml` 文件；
2. 通过 `jinja2` 渲染模板逻辑；
3. 使用 `ruamel.yaml` 解析 YAML；
4. 转换为 `dict` 供解释器运行。

这种方式虽对小型项目足够，但当 YAML 文件嵌套结构复杂、模块众多时，问题显现：

- ⏳ **启动缓慢**：每次重复执行 jinja2 渲染和 YAML 解析；
- 💥 **内存激增**：一次性加载整个字典结构；
- 🐌 **性能随项目规模劣化**：越大越卡，越多越慢。

因此，我们决定彻底重构运行核心。

---

## ✨ 新架构：ybc 字节码系统上线！

我们设计了一种全新机制：

> **将 YAML 编译为 SQLite 存储结构（.ybc），运行时按需访问。**

`.ybc` 是一种结构化键值数据库 + 字节码容器，具备以下优势：

### 🔥 一次编译，多次运行

- 初次构建时，`.yaml` 被编译为 `.ybc`；
- 编译流程完成模板渲染、AST 抽取、结构写入 SQLite；
- 运行阶段直接读取 `.ybc`，**无需再解析原始 YAML**。

### ❄️ 惰性加载：只加载被用到的内容

旧版加载整个 dict，新版则：

> **运行时仅加载访问到的键，而非整棵 YAML 树。**

实测（4.6 万行、无模板）：

| 格式 | 启动时间 | 内存占用 |
|------|----------|----------|
| YAML | 3.2 秒   | 186 MB   |
| YBC  | 0.04 秒  | 90 MB    |

---

## ⚙️ JIT 模板引擎：字符串渲染性能突破

模板字符串（如 `{< time.time() >}`）是 Yuml 的核心语法。旧版本每次渲染：

1. 正则拆分表达式；
2. `eval` 执行；
3. 拼接渲染输出。

### 🌀 问题：

在循环中反复渲染模板（如 `range(100000)`）会产生大量重复解析和执行，浪费性能。

---

### 🚀 新方案：表达式级 JIT 缓存

新版本内置智能模板缓存引擎，可自动识别 **高频表达式** 并编译为 `lambda` 函数：

- 📌 第一次出现：常规解析；
- 📌 出现 ≥3 次：标记为热点表达式；
- 📌 后续使用：复用已编译 lambda，跳过正则与 eval；

这就是 Yuml 的 **表达式级 JIT 编译**。

### ⚠️ 缓存“表达式”，而非“结果”！

我们只缓存表达式的可执行函数，不缓存其值：

\```yaml
{< time.time() >}  # 每次结果不同，不能缓存结果，只能缓存 lambda
\```

---

## 🧪 示例对比：旧 vs 新

```yaml
run:
  $app::comImportPackage: [["from time import perf_counter", "perf_counter"], {}]
  \>start_time: perf_counter()
  FOR:
    ITER: range(100000)
    CODE:
      CALL_BLOCK: ["{< 'test' >}", ["{< 1+1 >} :int"]]
  LOG: "{< perf_counter() - start_time >}"

test: {}
```

| 模式 | 总耗时 |
|------|--------|
| 旧版 | 1.53s  |
| 新版（含 JIT） | **1.34s** ✔️ |

模板调用越频繁，提速越明显！

---

## 🛠️ 双模式支持：开发 & 部署无缝切换

新架构保留双模式，兼顾灵活与性能：

| 模式 | 描述 | 适用场景 |
|------|------|----------|
| `.yaml` 直跑 | 动态解析，易调试 | 本地开发、快速迭代 |
| `.ybc` 编译执行 | 惰性 + 缓存 | 正式部署、性能敏感 |

---

## 🎯 总结

Yuml 新架构具备：

- ✅ **字节码级虚拟执行系统**
- ⚡ **表达式级 JIT 缓存机制**
- 🧊 **惰性内存调度引擎**
- 🧬 **完整动态语言支持**

> 我们没有牺牲动态性，而是用工程能力守护它。  
> 新架构，让 Yuml 更快、更轻、更强。