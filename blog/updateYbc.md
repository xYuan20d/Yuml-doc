---
slug: updateYbc
title: ✨ Yuml 架构升级：我们如何用 SQLite 实现 YAML 的惰性加载与编译执行
date: 2025-07-01
authors: [yuan]
tags: [Yuml]
---

Yuml 新版本引入了一项关键性的底层升级 ——  
我们重新设计了解析执行的整个流程，**告别重复渲染 + 全量加载的时代**，正式迈入**字节码 + 惰性加载的高性能阶段**。

<!--truncate-->

## 🧠 问题回顾：旧架构的瓶颈

在旧版本中，Yuml 的启动流程如下：

1. 读取原始 `.yaml` 文件；
2. 通过 `jinja2` 渲染模板逻辑；
3. 使用 `ruamel.yaml` 解析 YAML；
4. 将其转换为 `dict`，供解释器运行。

虽然这种机制对小项目足够，但当 YAML 文件**嵌套结构复杂、模块数量多时**，以下问题显现：

- ⏳ **启动速度极慢**：每次都重复执行 jinja2 + YAML 解析；
- 💥 **内存占用剧增**：全量 dict 加载会一次性占用大量内存；
- 🐌 **性能与规模成反比**：项目越大、越卡。

于是，我们决定 —— **动手重构运行核心**。

---

## ✨ 新架构：ybc 字节码系统上线！

我们设计了一种全新的运行机制：

> **将 YAML 编译为 SQLite 存储结构（ybc），按需访问执行内容。**

你可以把 `.ybc` 理解为一个 **结构化的键值数据库 + 字节码容器**，它具备以下特性：

### 🔥 编译机制（一次编译，多次运行）
- 首次构建时，将 `.yaml` 编译为 `.ybc` 文件；
- 编译过程中，完成模板渲染 + AST 提取 + SQLite 写入；
- 运行时，Yuml 直接读取 `.ybc`，**不再解析 YAML 原文**。

### ❄️ 惰性加载（用多少，读多少）
旧版会将整个 dict 一次性加载至内存，新版改为：

> **运行时只读取你访问的那个键值，而非整棵树。**

这得益于 SQLite 的键值查找能力，我们可以做到：
- 只加载需要的分支；
- **动态、低成本地解析执行逻辑**；
- 大幅节省内存（实测内存占用下降 80%+）；

---

## 🧪 示例对比：旧 vs 新

| 项目 | YAML 行数 | 启动时间（旧） | 启动时间（新） | 内存占用 |
|------|-----------|----------------|----------------|-----------|
| 小项目 | 300 行     | 200ms          | 60ms           | 30MB → 10MB |
| 中型项目 | 2000 行   | 1.4s           | 0.4s           | 120MB → 25MB |
| 超大项目 | >1w 行    | 无法启动💥     | 1.1s           | ❌ → 40MB |

---

## 🛠️ 双模式支持：开发 & 部署都方便

为了兼顾开发体验与部署性能，新版本保留两种运行方式：

| 模式 | 描述 | 推荐用途 |
|------|------|-----------|
| `.yaml` 直跑 | 保留解释器动态性 | 快速调试、开发阶段 |
| `.ybc` 编译运行 | 结构化 + 惰性 | 部署上线、追求性能场景 |
