---
sidebar_position: 2
title: 基本概念
id: concept
---

# Yuml 独有的基本概念

Yuml 是一种声明式 UI 与逻辑描述语言，具有独特的结构与语义体系。本节将介绍 Yuml 的核心组成：**块（Block）**与**元素（Element）**，以及它们在语言中的作用。

---

## 1. 块（Block）与元素（Element）

在 Yuml 中，每个根节点（Root）下都是一个“块”（Block）。块是 Yuml 的基本代码结构单元，用于封装逻辑、组件或数据内容。

### 示例
```yaml
a:
  _: 1

b:
  _: 1
  _2: 1
```

- 上例中，a 和 b 都是块，分别称为「a 块」和「b 块」。
- 每个块中的键值对称为元素（Element）。
- a 块中包含一个元素：`_`，值为 `1`。
- b 块中包含两个元素：`_` 和 `_2`，值均为 `1`。

### 组件元素

参考: [组件元素和普通元素](/docs/使用教程/mainBlocks#组件元素和普通元素)

---

## 2. Globals（全局变量）

`Globals` 是 Yuml 中最核心的概念之一。  
它的设计理念是：**在一个地方设置后，整个系统中所有语言层都可以同步访问。**

这意味着，无论是 YAML 脚本本身，还是 Python、Lua 等脚本语言，都可以共享访问同一个变量。

### 🔄 多语言同步示例

以下示例展示了如何通过 `Globals` 实现变量在多个语言环境中的共享：

```yaml
\>a: 1
LOG: "{< a >}"
PythonScript: "print(a)"
LuaScript: "print(a)"
```

输出：
```
1
1
1
```
在上例中，`\>a: 1` 定义了一个名为 `a` 的全局变量：  
- `{< a >}` 用于字符串渲染引擎中访问 `a`  
- Python 和 Lua 脚本中直接访问同名变量 `a`，无需额外传参

### 💡 其他创建 Globals 的方式

- `HOOK` 元素在执行时也会创建对应的全局变量  
- 某些组件行为、回调处理等也可能隐式地将变量注入为 `Globals`

### 🧹 生命周期与管理

- `Globals` 的生命周期 **贯穿整个应用运行期间**，不会自动销毁  
- 若需要手动清除变量，可使用 `DELETE` 元素进行删除：

```yaml
DELETE:
  - a
```

### 📘 延伸阅读

字符串渲染引擎中的 `{< a >}` 表达式同样依赖 `Globals` 提供变量支持，详见：  
[字符串渲染引擎](/docs/使用教程/string)

掌握 `Globals` 是 Yuml 编程的入门基础，也是数据交互的核心机制之一。

---

## 3.HOOK —— 捕获返回值的机制

在 Yuml 中，**每个元素或块都可能产生返回值**。  
但如果你不使用 **HOOK**，这个返回值将被自动忽略。

使用 HOOK，可以将返回值**赋值给一个变量名（全局变量）**，用于后续逻辑中使用。  
如果该元素/块没有返回值，则默认返回 `None`。

### 🧾 HOOK 的两种写法

#### ✅ 标准写法

```yaml
HOOK:
  result:
    _test: 10  # 假设 _test 元素会返回 10

LOG: "{< result >}"  # 输出 10
```

#### ✅ 简洁写法（推荐）

```yaml
\#result:
  _test: 10

LOG: "{< result >}"  # 输出 10
```

这两种写法功能完全一致，简洁写法更方便快捷。

### 📦 块也有返回值

每个块（Block）也支持返回值，使用 `RETURN` 元素返回一个结果。

你可以结合 `CALL_BLOCK` 与 HOOK 捕获块的返回值：

```yaml
windowCreated:
  \#value:
    CALL_BLOCK: testBlock

  LOG: "{< value >}"  # 输出 test

testBlock:
  RETURN: "test"
```

### 📘 小提示

- **HOOK 创建的是Globals**，所以你可以在任何位置通过 `{< 名称 >}` 获取值。
- 多数元素（如组件创建、逻辑判断）都支持 HOOK 捕获。
- 即使元素返回的是 `None`，也会正常创建对应的变量。

HOOK 是构建复杂逻辑时必不可少的机制，建议熟练掌握。

---

## 4️. `.accept` 参数机制

Yuml 中的 `\>` 语法通常用于通过 `eval` 动态定义变量，例如：

```yaml
\>a: 1
```

但你可能不知道，`a` 也可以赋值为特殊值 `.accept`，以实现块的“参数传递”功能。

### 📦 什么是 `.accept`？

在 Yuml 中，每个块都支持**类似函数的参数机制**，不过默认情况下不会启用。  
只有当你在块内部使用 `\>变量名: .accept` 语句时，Yuml 才会将外部传入的值赋给该变量。

### ✨ 示例

```yaml
windowCreated:
  CALL_BLOCK: ["testBlock", "hello world"]

testBlock:
  \>items: .accept
  LOG: "{< items >}"  # 输出 hello world
```

解释：

- `CALL_BLOCK` 第二个参数 `"hello world"` 会被作为参数传入 `testBlock`
- 在 `testBlock` 中，`items` 被定义为 `.accept`，因此自动获得传入值

### ⚠️ 注意事项

- 每个块**只能接收一个参数值**
- 如果你需要传递多个值，请将它们**打包成一个列表**或对象

```yaml
CALL_BLOCK: ["testBlock", ["a", "b", "c"]]
```

### 🧠 补充说明

- `.accept` 机制**不会默认生效**，必须在块内部显式声明 `\>变量: .accept`
- `.accept` 机制未传递参数时会赋值为None(null)
- 这是 Yuml 提供的一种简洁函数参数绑定方式，特别适合用于逻辑块、模板块等

推荐与 `HOOK` 搭配使用，实现输入参数 → 返回值的完整封装模式。

---

## 5️. 控制流

虽然 Yuml 是一门声明式语言，但它拥有**完善的控制流机制**，远超多数声明语言的能力。  
它支持：

- `IF` 条件判断（包含 `ELSE` 与多条件模拟 `ELIF`）
- `FOR` 循环
- `WHILE` 循环
- 以及 `BREAK` / `CONTINUE` 关键控制语句

这些控制流语法，让 Yuml 拥有接近编程语言的逻辑表达能力。

### 🔁 FOR 循环示例

```yaml
FOR:
  ITER: range(10)  # 注意：ITER 中的内容会自动使用 eval 执行 Python 表达式
  NAME: i
  CODE:
    LOG: "{< i >}"
```

> 输出 0 到 9 的数字（每行一个）

### 🧠 IF 条件判断示例

```yaml
\>age: 18

IF:
  age >= 18:
    LOG: "成年"
  ELSE:
    LOG: "未成年"
```

### ➕ 多分支判断（模拟 `elif`）

Yuml 不直接提供 `elif`，但你可以通过多个判断键模拟：

```yaml
IF:
  age >= 22:
    LOG: "到达法定结婚年龄"
  age >= 18:
    LOG: "成年"
  ELSE:
    LOG: "未成年"
```

Yuml 会从上到下依次判断条件，**只执行第一个满足条件的分支**。

### 🧭 更多内容

- `WHILE` 循环
- `BREAK` / `CONTINUE` 跳出循环控制
- `ELSE` 分支逻辑
- `RETURN` 控制块返回值

请查看完整文档：[控制流详解](/docs/使用教程/OR)

控制流是 Yuml 脱离传统 XML/HTML 样式系统，迈向“有逻辑的声明式语言”的关键部分，建议务必掌握。

---

## 6️. 字符串渲染

字符串渲染是 Yuml 的**核心机制之一**。  
你可能已经注意到，很多元素的值中可以包含 `{<>}` 这样的表达式，这并不是普通的字符串插值，而是一套强大的 **“字符串 + 代码混合执行机制”**。

### ✨ 渲染机制简介

Yuml 在运行时会对所有字符串中出现的 `{< 表达式 >}` 进行自动识别，并通过 **正则 + `eval` 执行**，将其转译为对应的值。

例如：

```yaml
\>a: 2
LOG: "结果是 {< a + 3 >}"  # 输出：结果是 5
```

### 📘 更多特性

- 支持 `:int`、`:obj` 等后缀控制返回类型
- 多表达式渲染
- `{{<< >>}}` 转义机制（防止渲染）
- 支持表达式嵌套和列表拼接等高级语法

详细语法规则请查阅完整文档：[字符串渲染引擎](/docs/使用教程/string)

:::tip 小贴士
几乎所有元素值在执行前都会自动经过字符串渲染引擎处理。
:::

---

## 7️. 前后端交互特性

Yuml 原生支持 **前后端分离式开发**：  
- 前端：使用 Yuml 编写 UI 逻辑  
- 后端：使用 Python 编写业务逻辑  

通过简单的配置，你可以轻松将前端事件与 Python 函数连接起来，构建动态交互的桌面应用。

### 🚩 启用前后端交互

你需要通过 `$app::setPython` 元素绑定 Python 后端文件：

```yaml
$app::setPython: [["test"], {}]  # test.py 会自动被导入并用于交互
```

### 🧩 后端 Python 编写

你的 Python 文件（如 `test.py`）中，需要定义一个 `APP` 类并继承内置的 `YAPP`：

```python
from YUML.YmlAPIS.python import YAPP

class APP(YAPP):
    ...
```

:::warning
必须继承自 `YAPP`，否则 Yuml 无法识别你的类！
:::

### 🎯 使用按钮触发交互（示例）

**Yuml 前端文件：**

```yaml
button:
  button1:
    show: true
    onClicked: button1_clicked
```

**test.py 后端文件：**

```python
class APP(YAPP):
    def __init__(self, raw):
        self.raw = raw

    def button1_clicked(self, info):
        button = info[0]  # 第一个参数是被点击的按钮对象
        button.setText("按钮被点击！")
```

### 📚 更多玩法

你可以在前端的 **按钮、某些事件块** 等处调用后端 Python 函数，实现更复杂的交互逻辑。  
详见：[前后端交互完整文档](/docs/使用教程/full)

Yuml 的交互机制完全基于反射，开发者几乎不需要额外桥接代码，**函数名对上即可自动绑定**，极大提升开发效率。